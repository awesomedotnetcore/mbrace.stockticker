<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Vagabond</name></assembly>
<members>
<member name="P:Nessos.Vagabond.AssemblyId.Extension">
<summary>
 Specifies the filename extension.
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyId.ImageHash">
<summary>
 digest of the raw assembly image
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyId.FullName">
<summary>
 assembly qualified name
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyId.IsStrongAssembly">
<summary>
 Is signed assembly
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AssemblyId.GetName">
<summary>
 Returns a System.Reflection.AssemblyName corresponding to Assembly id
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyId">
<summary>
 Vagabond unique assembly identifier
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyLoadInfo.Loaded">
<summary>
 Assembly successfuly loaded in remote party.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyLoadInfo.LoadFault">
<summary>
 Error when attempting to load assembly.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyLoadInfo.NotLoaded">
<summary>
 Assembly does not exist in remote party.
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyLoadInfo">
<summary>
 Assembly load information
</summary>
</member>
<member name="F:Nessos.Vagabond.AssemblyLoadPolicy.RequireIdentical">
<summary>
 If assembly is to be resolved locally, then it should have identical image hash.
</summary>
</member>
<member name="F:Nessos.Vagabond.AssemblyLoadPolicy.ResolveAll">
<summary>
 All assembly names can be looked up by runtime
</summary>
</member>
<member name="F:Nessos.Vagabond.AssemblyLoadPolicy.ResolveStrongNames">
<summary>
 Only signed assemblies should be looked up by runtime
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyLoadPolicy">
<summary>
 Specifies what assemblies are to be loaded 
 locally by the runtime if possible.
</summary>
</member>
<member name="T:Nessos.Vagabond.DataDependency.Persisted">
<summary>
 Data dependency pickled to file; reserved for large data bindings
</summary>
</member>
<member name="T:Nessos.Vagabond.DataDependency.Pickled">
<summary>
 Data dependency pickled in-memory
</summary>
</member>
<member name="T:Nessos.Vagabond.DataDependency.Errored">
<summary>
 Data dependency failed to serialize
</summary>
</member>
<member name="T:Nessos.Vagabond.DataDependency">
<summary>
 Specifies data dependency content
</summary>
</member>
<member name="T:Nessos.Vagabond.DataDependencyId">
<summary>
 Data dependency identifier
</summary>
</member>
<member name="P:Nessos.Vagabond.DataDependencyInfo.Data">
<summary>
 Data dependency container.
</summary>
</member>
<member name="P:Nessos.Vagabond.DataDependencyInfo.FieldInfo">
<summary>
 Pickled static field from which data was extracted.
</summary>
</member>
<member name="P:Nessos.Vagabond.DataDependencyInfo.Generation">
<summary>
 Data dependency generation.
</summary>
</member>
<member name="P:Nessos.Vagabond.DataDependencyInfo.Name">
<summary>
 Human-readable dependency identifier.
</summary>
</member>
<member name="P:Nessos.Vagabond.DataDependencyInfo.Id">
<summary>
 Unique identifier
</summary>
</member>
<member name="T:Nessos.Vagabond.DataDependencyInfo">
<summary>
 Data dependency information
</summary>
</member>
<member name="T:Nessos.Vagabond.DataGeneration">
<summary>
 Pickle generation id for data dependency
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.DefaultDynamicAssemblyProfile">
<summary>
 Default dynamic assembly profile; no erasure, no static initialization.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.FsiDynamicAssemblyProfile">
<summary>
 Dynamic Assembly profile for F# Interactive
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyExporter.WriteMetadata(Nessos.Vagabond.AssemblyId,Nessos.Vagabond.VagabondMetadata)">
<summary>
 Asynchronously writes Vagabond metadata for assembly of provided id.
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyExporter.TryGetSymbolsWriter(Nessos.Vagabond.AssemblyId)">
<summary>
 Asynchronously returns a write stream for assembly debug symbols of given id. Returns &apos;None&apos; if symbols already exist.
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyExporter.TryGetMetadata(Nessos.Vagabond.AssemblyId)">
<summary>
 Asynchronously returns currently stored Vagabond metadata for given id. Returns &apos;None&apos; if it does not exist.
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyExporter.TryGetImageWriter(Nessos.Vagabond.AssemblyId)">
<summary>
 Asynchronously returns a write stream for assembly image of given id. Returns &apos;None&apos; if image already exists.
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyExporter.GetPersistedDataDependencyReader(Nessos.Vagabond.AssemblyId,Nessos.Vagabond.DataDependencyInfo)">
<summary>
 Asynchronously returns a write stream for writing supplied persisted data dependency.
</summary>
</member>
<member name="T:Nessos.Vagabond.IAssemblyExporter">
<summary>
 Abstract assembly image exporting API
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyImporter.TryGetSymbolReader(Nessos.Vagabond.AssemblyId)">
<summary>
 Asynchronously returns a read stream for assembly debug symbols of given id.
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyImporter.ReadMetadata(Nessos.Vagabond.AssemblyId)">
<summary>
 Asynchronously reads Vagabond metadata information for assembly of given id.
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyImporter.GetPersistedDataDependencyReader(Nessos.Vagabond.AssemblyId,Nessos.Vagabond.DataDependencyInfo)">
<summary>
 Asynchronously returns a read stream for Vagabond data of given id.
</summary>
</member>
<member name="M:Nessos.Vagabond.IAssemblyImporter.GetImageReader(Nessos.Vagabond.AssemblyId)">
<summary>
 Asynchronously returns a read stream for assembly image of given id.
</summary>
</member>
<member name="T:Nessos.Vagabond.IAssemblyImporter">
<summary>
 Abstract assembly image importing API
</summary>
</member>
<member name="P:Nessos.Vagabond.IDynamicAssemblyProfile.Description">
<summary>
 a short description of the profile
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.PickleStaticField(System.Reflection.FieldInfo,System.Boolean)">
<summary>
 Specifies if static field is to be pickled
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.IsMatch(System.Reflection.Assembly)">
<summary>
 identifies dynamic assemblies that match this profile
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.EraseType(System.Type)">
<summary>
 Specifies if type is to be erased from slices
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.EraseStaticConstructor(System.Type)">
<summary>
 Specifies if static constructor is to be erased
</summary>
</member>
<member name="M:Nessos.Vagabond.IDynamicAssemblyProfile.AlwaysIncludeType(System.Type)">
<summary>
 Specifies if type is to be included in every iteration of the slice
</summary>
</member>
<member name="T:Nessos.Vagabond.IDynamicAssemblyProfile">
<summary>
 customizes slicing behaviour on given dynamic assembly
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.NativeAssemblyManager.LoadedNativeAssemblies">
<summary>
 Gets loaded native assemblies
</summary>
</member>
<member name="M:Nessos.Vagabond.NativeAssemblyManager.TryFind(Nessos.Vagabond.AssemblyId)">
<summary>
 Try get assembly that is loaded in native assembly state
</summary>
</member>
<member name="M:Nessos.Vagabond.NativeAssemblyManager.Load(Nessos.Vagabond.VagabondAssembly)">
<summary>
 Loads a native assembly by copying to the native path
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.NativeAssemblyManager">
<summary>
 AppDomain-specific native assembly container
 container is added to local PATH and copied
 from cache whenever loaded
</summary>
</member>
<member name="M:Nessos.Vagabond.Vagabond.Initialize(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.IDynamicAssemblyProfile}},Microsoft.FSharp.Core.FSharpOption{Nessos.FsPickler.ITypeNameConverter},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int64})">
 <summary>
     Initializes a new Vagabond instance.
 </summary>
 <param name="ignoredAssemblies">Ignore assemblies and their dependencies.</param>
 <param name="cacheDirectory">Temp folder used for assembly compilation and caching. Defaults to system temp folder.</param>
 <param name="profiles">Dynamic assembly configuration profiles.</param>
 <param name="typeConverter">FsPickler type name converter.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
 <param name="loadPolicy">Default assembly load policy.</param>
 <param name="compressDataFiles">Compress data files generated by Vagabond. Defaults to true.</param>
 <param name="dataPersistThreshold">
     Specifies persist threshold for data dependencies in bytes.
     Objects exceeding the threshold will be persisted to files,
     while all-others will be pickled in-memory. Defaults to 10KiB.
 </param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.Initialize(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.IDynamicAssemblyProfile}},Microsoft.FSharp.Core.FSharpOption{Nessos.FsPickler.ITypeNameConverter},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Int64})">
 <summary>
     Initializes a new Vagabond instance.
 </summary>
 <param name="cacheDirectory">Temp folder used for assembly compilation and caching. Defaults to system temp folder.</param>
 <param name="profiles">Dynamic assembly configuration profiles.</param>
 <param name="typeConverter">FsPickler type name converter.</param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
 <param name="loadPolicy">Default assembly load policy.</param>
 <param name="compressDataFiles">Compress data files generated by Vagabond. Defaults to true.</param>
 <param name="dataPersistThreshold">
     Specifies persist threshold for data dependencies in bytes.
     Objects exceeding the threshold will be persisted to files,
     while all-others will be pickled in-memory. Defaults to 10 KiB.
 </param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.GetFileName(Nessos.Vagabond.AssemblyId)">
 <summary>
     Generates a unique file name that corresponds to the particular assembly id.
     Useful for caching implementations.
 </summary>
 <param name="id">Input assembly identifier</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ComputeTypeDependencies(System.Object)">
 <summary>
     Returns all type instances that appear in given object graph.
 </summary>
 <param name="obj">object graph to be traversed</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ComputeAssemblyIds(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
 <summary>
     Computes unique id's for a collection of static assemblies.
 </summary>
 <param name="assemblies">Input static assemblies</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ComputeAssemblyId(System.Reflection.Assembly)">
 <summary>
     Computes a unique id for given static assembly.
 </summary>
 <param name="assembly">Input static assembly.</param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ComputeAssemblyDependencies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Resolves all assembly dependencies of given assemblies.
 </summary>
 <param name="assemblies">Starting assembly dependencies.</param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ComputeAssemblyDependencies(System.Reflection.Assembly,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Resolves all assembly dependencies of given assembly.
 </summary>
 <param name="assembly">assembly to be traversed</param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
</member>
<member name="M:Nessos.Vagabond.Vagabond.ComputeAssemblyDependencies(System.Object,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean}},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Resolves all assembly dependencies of given object graph.
 </summary>
 <param name="obj">object graph to be traversed</param>
 <param name="isIgnoredAssembly">User-defined assembly ignore predicate.</param>
 <param name="requireLoadedInAppDomain">
     Demand all transitive dependencies be loadable in current AppDomain.
     If unset, only loaded assemblies are listed as dependencies. Defaults to true.
 </param>
</member>
<member name="T:Nessos.Vagabond.Vagabond">
 <summary>
     A collection of general purpose utilities on dependency traversal.
 </summary>
</member>
<member name="P:Nessos.Vagabond.VagabondAssembly.PersistedDataDependencies">
<summary>
 Paths to bindings that are persisted to disk
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondAssembly.Metadata">
<summary>
 Vagabond metadata and static initialization data path
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondAssembly.Symbols">
<summary>
 path to symbols file
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondAssembly.Image">
<summary>
 path to assembly
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondAssembly.Id">
<summary>
 Assembly Identifier
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondAssembly.FullName">
<summary>
 Assembly qualified name
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.VagabondAssembly.GetName">
<summary>
 Returns a System.Reflection.AssemblyName corresponding to Assembly id
</summary>
</member>
<member name="T:Nessos.Vagabond.VagabondAssembly">
<summary>
 Exportable Vagabond assembly and metadata
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.VagabondException">
<summary>
 Exception raised by Vagabond
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.VagabondManager.DefaultLoadPolicy(Nessos.Vagabond.AssemblyLoadPolicy)">
<summary>
 Gets or sets the default load policy for the instance
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondManager.UUId">
<summary>
 Unique identifier for the slice compiler
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondManager.TypeConverter">
<summary>
 FsPickler type name converter for use with other formats
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondManager.Pickler">
<summary>
 Returns the pickler used by the slice compiler
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondManager.NativeDependencies">
<summary>
 Returns all unmanaged dependencies registered to Vagabond instance.
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondManager.DefaultLoadPolicy">
<summary>
 Gets or sets the default load policy for the instance
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondManager.CachePath">
<summary>
 Cache directory used by Vagabond
</summary>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.TryGetSliceOfType(System.Type)">
 <summary>
     Returns the dynamic assembly slice corresponding to the given type, if exists.
 </summary>
 <param name="t">input type.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.ResolveDynamicDependenciesRequiringCompilation(System.Object)">
 <summary>
     Returns a list of dynamic assemblies that require slice compilation
     for the given object graph to be exportable.
 </summary>
 <param name="obj">any object graph</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.RegisterNativeDependency(System.String)">
 <summary>
     Includes an unmanaged assembly dependency to the vagabond instance.
 </summary>
 <param name="path">Path to the unmanaged assembly.</param>
 <param name="name">Identifier for unmanaged assembly. Defaults to the assembly file name.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.LoadVagabondAssembly(Nessos.Vagabond.AssemblyId,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Attempt loading vagabond assembly of given id to the local AppDomain.
 </summary>
 <param name="id">input assembly id.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.LoadVagabondAssembly(Nessos.Vagabond.VagabondAssembly,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Loads vagabond assembly to the local AppDomain.
 </summary>
 <param name="va">Input assembly package.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.LoadVagabondAssemblies(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Attempt loading vagabond assemblies of given id's to the local AppDomain.
 </summary>
 <param name="id">input assembly id.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.LoadVagabondAssemblies(System.Collections.Generic.IEnumerable{Nessos.Vagabond.VagabondAssembly},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Loads vagabond assemblies to the local AppDomain.
 </summary>
 <param name="vas">Input assembly packages.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.IsLocalDynamicAssemblySlice(Nessos.Vagabond.AssemblyId)">
 <summary>
     Checks if assembly id is a locally generated dynamic assembly slice.
 </summary>
 <param name="id">input assembly id.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.ImportAssemblies(Nessos.Vagabond.IAssemblyImporter,System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId})">
 <summary>
     Import provided assemblies to cache using provided importer.
 </summary>
 <param name="importer">Assembly importer implementation.</param>
 <param name="ids">Assembly id's to be imported.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.GetVagabondAssembly(System.Reflection.Assembly)">
 <summary>
     Gets vagabond assembly metadata for given static assembly.
 </summary>
 <param name="assembly">Given assembly.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.GetVagabondAssembly(Nessos.Vagabond.AssemblyId,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Gets vagabond assembly metadata for given assembly id.
 </summary>
 <param name="id">assembly id</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.GetVagabondAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Gets vagabond assembly metadata for given static assemblies.
 </summary>
 <param name="assemblies">Inputs assemblies.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.GetVagabondAssemblies(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
    Gets vagabond assembly metadata for given assembly ids.
 </summary>
 <param name="ids">assembly ids.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.GetDynamicAssemblySlices(System.Reflection.Assembly)">
 <summary>
     Returns *all* assembly slices of given dynamic assembly.
 </summary>
 <param name="assembly">a dynamic assembly.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.GetAssemblyLoadInfo(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Gets the local assembly load info for given assembly ids.
 </summary>
 <param name="ids">Given assembly ids.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.GetAssemblyLoadInfo(Nessos.Vagabond.AssemblyId,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Gets the local assembly load info for given assembly id.
 </summary>
 <param name="id">Given assembly id.</param>
 <param name="loadPolicy">Specifies assembly resolution policy. Defaults to resolving strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.ExportAssemblies(Nessos.Vagabond.IAssemblyExporter,System.Collections.Generic.IEnumerable{Nessos.Vagabond.VagabondAssembly})">
 <summary>
     Export provided assemblies using provided exporter
 </summary>
 <param name="exporter">Assembly exporter implementation.</param>
 <param name="assemblies">Assemblies to be exported.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.ComputeObjectDependencies(System.Object,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Returns a collection of all assemblies that the given object depends on.
     Dynamic assemblies are substituted for their corresponding static slices.
 </summary>
 <param name="obj">A given object graph</param>
 <param name="permitCompilation">Compile new slices as required. Defaults to false.</param>
</member>
<member name="M:Nessos.Vagabond.VagabondManager.CompileDynamicAssemblySlice(System.Reflection.Assembly)">
 <summary>
     Compiles slices for given dynamic assembly, if required.
 </summary>
 <param name="assembly">a dynamic assembly</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.VagabondManager">
<summary>
 Vagabond management object which instantiates a dynamic assembly compiler, loader and exporter states
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondMetadata.DataDependencies">
<summary>
 Static data dependencies for assembly; 
 used in dynamic assembly slices with erased static constructors.
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondMetadata.IsDynamicAssemblySlice">
<summary>
 Specifies if assembly is dynamic assembly slice.
</summary>
</member>
<member name="P:Nessos.Vagabond.VagabondMetadata.IsManagedAssembly">
<summary>
 Specifies if is managed CIL assembly.
</summary>
</member>
<member name="T:Nessos.Vagabond.VagabondMetadata">
<summary>
 Vagabond metadata for dynamic assembly slices
</summary>
</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.AppDomainPool.AppDomainEvaluatorPool.MinDomains">
<summary>
 Minimum allowed AppDomain count
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.AppDomainEvaluatorPool.MaxDomains">
<summary>
 Maximum allowed AppDomain count
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.AppDomainEvaluatorPool.DomainCount">
<summary>
 Current AppDomain count
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.AppDomainEvaluatorPool.EvaluateAsync``1(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},Microsoft.FSharp.Control.FSharpAsync{``0})">
 <summary>
     Asynchronously evaluates function in pooled AppDomain. AppDomain will be selected based on dependency affinity.
 </summary>
 <param name="dependencies">Dependencies for operation.</param>
 <param name="f">Asynchronous workflow to be executed.</param>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.AppDomainEvaluatorPool.Evaluate``1(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>
     Evaluates function in pooled AppDomain. AppDomain will be selected based on dependency affinity.
 </summary>
 <param name="dependencies">Dependencies for operation.</param>
 <param name="f">Function to be executed.</param>
</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AppDomainPool.AppDomainEvaluatorPool.Create(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.TimeSpan},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
 <summary>
     Creates a new AppDomainEvaluator instance.
 </summary>
 <param name="appDomainInitializer">Initializer run on every AppDomain upon creation. Defaults to none.</param>
 <param name="minimumConcurrentDomains">Minimum allowed AppDomains. Defaults to 3.</param>
 <param name="maximumConcurrentDomains">Maximum allowed AppDomains. Defaults to 20.</param>
 <param name="threshold">TimeSpan after which unused AppDomains may get unloaded. Defaults to infinite.</param>
 <param name="maxTasksPerDomain">Maximum number of tasks allowed per domain. Defaults to infinite.</param>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.AppDomainEvaluatorPool">
<summary>
 Defines an app domain pool that evaluates code based on Vagabond dependency affinities
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.AppDomainPool">
<summary>
 Provides an AppDomain pooling mechanism for use by Vagabond.
 AppDomains are managed based what assembly dependencies are required for execution.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.AppDomainPool.AppDomainPool`1.MinDomains">
<summary>
 Minimum AppDomain count
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.AppDomainPool`1.MaxDomains">
<summary>
 Maximum AppDomain count
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.AppDomainPool`1.DomainCount">
<summary>
 Current AppDomain count
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.AppDomainPool`1.RequestAppDomain(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId})">
 <summary>
     Returns a marshalled Manager object attached to a pooled AppDomain instance.
     AppDomain will be selected based on dependency affinity.
 </summary>
 <param name="dependencies">Assembly dependencies required of AppDomain.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.AppDomainPool`1">
<summary>
 Provides an AppDomain pooling mechanism for use by Vagabond.
 AppDomains are managed based what assembly dependencies are required for execution.
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.IAppDomainManager.TaskCount">
<summary>
 Gets the number of tasks currently active in the AppDomain. 
 AppDomains with non-zero task count will never be unloaded
 by the AppDomainPool.
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.IAppDomainManager.LastUsed">
<summary>
 Gets the last time this app domain instance was used.
 Used by the AppDomainPool to unload unused instances.
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.IAppDomainManager.Initialize(Nessos.Vagabond.AppDomainPool.IAppDomainConfiguration)">
<summary>
 AppDomain initializer method.
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.IAppDomainManager.Finalize">
<summary>
 AppDomain finalization method.
</summary>
</member>
<member name="T:Nessos.Vagabond.AppDomainPool.IAppDomainManager">
<summary>
 Interface implemented by MarshalByRef types
 used for managing Application domains.
 Types implementing the interface must carry
 a parameterless constructor.
</summary>
</member>
<member name="T:Nessos.Vagabond.AppDomainPool.IAppDomainConfiguration">
<summary>
 User-defined configuration object
 passed at AppDomain initialization
 Values are instantiated on the client appdomain
 and marshalled to the pooled domains
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.AppDomainEvaluatorManager.EvaluateSync(Nessos.FsPickler.ExtensionMethods.Pickle{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Object}})">
<summary>
 Synchronously executes a computation in remote AppDomain
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.AppDomainEvaluatorManager.EvaluateAsync(Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledTaskCompletionSource{Nessos.FsPickler.ExtensionMethods.Pickle{Nessos.Vagabond.Utils.Exn{System.Object}}},Nessos.FsPickler.ExtensionMethods.Pickle{Microsoft.FSharp.Control.FSharpAsync{System.Object}})">
<summary>
 Asynchronously executes a computation in remote AppDomain
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.AppDomainEvaluatorManager">
<summary>
 AppDomain managing object
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.AppDomainEvaluatorConfiguration">
<summary>
 AppDomain configuration that carries a pickled initializer
</summary>
</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledCancellationTokenSource.CancellationToken">
<summary>
 Gets the local cancellation token
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledCancellationTokenSource.Cancel">
<summary>
 Cancel the cancellation token source
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledCancellationTokenSource">
<summary>
 Marshalled cancellation token source for use over AppDomains
</summary>
</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledTaskCompletionSource`1.Task">
<summary>
 Gets the local task instance.
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledTaskCompletionSource`1.SetResult(`0)">
<summary>
 Set a value as task result
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledTaskCompletionSource`1.SetException(System.Exception)">
<summary>
 Set an exception as task result
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledTaskCompletionSource`1.SetCanceled">
<summary>
 Cancels the task
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.EvaluatorImpl.MarshalledTaskCompletionSource`1">
<summary>
 Marshalled task completion source for async computation over AppDomains
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.EvaluatorImpl">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.UnloadThreshold">
<summary>
 Unload threshold: minimum timespan needed for unloading unused domains
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.Configuration">
<summary>
 User-specified configuration for the AppDomain
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.MaxTasksPerDomain">
<summary>
 Max tasks allowed per domain
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.MinConcurrentDomains">
<summary>
 Minimum concurrent domains
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.MaxConcurrentDomains">
<summary>
 Maximum concurrent domains
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.DomainPool">
<summary>
 Application domain pool
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.Init``1(System.Int32,System.Int32,Nessos.Vagabond.AppDomainPool.IAppDomainConfiguration,Microsoft.FSharp.Core.FSharpOption{System.TimeSpan},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Initialize a new AppDomain pool state
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.AddNew(Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId}})">
<summary>
 Initialize a new AppDomain with provided dependencies and add to state
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1.AddDomain(Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo{`0})">
<summary>
 Add existing or updated AppDomain info to state
</summary>
</member>
<member name="T:Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo`1">
<summary>
 Globad AppDomain load state
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo`1.Dependencies">
<summary>
 Declared Vagabond dependency load state
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo`1.Manager">
<summary>
 AppDomain manager instance
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo`1.AppDomain">
<summary>
 AppDomain instance
</summary>
</member>
<member name="P:Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo`1.Id">
<summary>
 AppDomain identifier
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo`1.Init(Nessos.Vagabond.AppDomainPool.IAppDomainConfiguration,Microsoft.FSharp.Core.FSharpOption{System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId}})">
<summary>
 Initialize an AppDomain instance with given Vagabond dependencies
</summary>
</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo`1">
<summary>
 Application Domain load state
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.behaviour``2(Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo{``0}},Microsoft.FSharp.Control.FSharpMailboxProcessor{Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolMsg{``0}})">
<summary>
 AppDomainManager actor behaviour
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.getMatchingAppDomain``1(Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo{``0},Nessos.Vagabond.AssemblyId[])">
<summary>
 get an Application domain appropriate for provided dependencies
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.cleanupDomains``1(System.Int32,Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo{``0})">
 <summary>
     clean up state from AppDomains needing removal.
 </summary>
 <param name="minRemovals">Minimum removals required for success.</param>
 <param name="state">Input state.</param>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.disposeDomains``1(System.Collections.Generic.IEnumerable{Nessos.Vagabond.AppDomainPool.Impl.AppDomainLoadInfo{``0}})">
<summary>
 unloads provided application domains
</summary>
</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.tryGetMatchingAppDomain``1(Nessos.Vagabond.AppDomainPool.Impl.AppDomainPoolInfo{``0},Nessos.Vagabond.AssemblyId[])">
<summary>
 try locating an AppDomain from pool that is compatible with supplied dependencies.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AppDomainPool.Impl.initAppDomain(System.String)">
<summary>
 initialize a new AppDomain with given friendly name
</summary>
</member>
<member name="T:Nessos.Vagabond.AppDomainPool.Impl">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.AssemblyCache.AssemblyCache.CacheDirectory">
<summary>
 Current cache directory
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyCache.AssemblyCache.TryGetCachedAssembly(Nessos.Vagabond.AssemblyId)">
<summary>
 Returns cached assembly of provided id, if it exists
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyCache.AssemblyCache.IsCachedAssembly(Nessos.Vagabond.AssemblyId)">
<summary>
 Checks if assembly of provided id exists in cache
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyCache.AssemblyCache.Import(Nessos.Vagabond.IAssemblyImporter,Nessos.Vagabond.AssemblyId)">
<summary>
 Import assembly of given id to cache
</summary>
</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AssemblyCache.AssemblyCache.Export(Nessos.Vagabond.IAssemblyExporter,Nessos.Vagabond.VagabondAssembly)">
<summary>
 Exports assembly of given id from cache
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyCache.AssemblyCache.CreateVagabondAssembly(System.Reflection.Assembly,System.Boolean)">
<summary>
 Creates a Vagabond assembly record for given System.Reflection.Assembly.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyCache.AssemblyCache">
<summary>
 Contains methods for caching assemblies and vagabond metadata to specified folder.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyCache">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AssemblyManagement.getAssemblyLoadInfo(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,Nessos.Vagabond.AssemblyLoadPolicy,Nessos.Vagabond.AssemblyId)">
<summary>
 assembly load status implementation

</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyManagement.exportAssembly(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,Nessos.Vagabond.AssemblyLoadPolicy,Nessos.Vagabond.AssemblyId)">
<summary>
 creates an exportable assembly package for given Assembly Id

</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyManagement">

</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.NativeAssemblyManager">
<summary>
 Native assembly manager
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.AssemblyCache">
<summary>
 Assembly Cache instance
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.Serializer">
<summary>
 Vagabond Serializer instance
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.AssemblyImportState">
<summary>
 Imported assembly load state
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.AssemblyExportState">
<summary>
 Assembly export state
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.DataImportState">
<summary>
 Local data import state
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.DataExportState">
<summary>
 Locally compiled dynamic assembly data export state
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.CompilerState">
<summary>
 Dynamic assembly compiler state
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.DataPersistThreshold">
<summary>
 Size threshold in bytes after which a data dependency will be persisted to file.
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.VagabondState.CompressDataFiles">
<summary>
 Use Gzip compression for persisted data files.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyManagementTypes.VagabondState">
<summary>
 Immutable Vagabond state object
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.DataExportState.PersistFile">
<summary>
 Data persist file for dependency
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.DataExportState.Hash">
<summary>
 Hashcode or serialization exception for last exported value
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.DataExportState.Info">
<summary>
 Last data dependency info
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyManagementTypes.DataExportState.AssemblyPath">
<summary>
 Assembly path for slice
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyManagementTypes.DataExportState">
<summary>
 Local dynamic assembly slice data dependency export state
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyManagementTypes">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.AssemblyIdGenerator.GetManagedAssemblyId(System.String)">
<summary>
 Unmemoized, unmanaged assembly id generator
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.AssemblyIdGenerator.GetManagedAssemblyId(System.Reflection.Assembly)">
<summary>
 Computes the assembly id for provided managed assembly.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyNaming.AssemblyIdGenerator">
<summary>
 computes a unique assembly identifier
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.VagabondAssembly.CreateManaged.Static(System.Reflection.Assembly,System.Boolean,Nessos.Vagabond.DataDependencyInfo[],System.Tuple{System.Int32,System.String}[])">
<summary>
 Defines un unmanaged VagabondAssembly for provided managed assembly
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.VagabondAssembly.CreateUnmanaged.Static(System.String)">
<summary>
 Defines an unmanaged VagabondAsembly for provided file
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.AssemblyId.GetFileName(Nessos.Vagabond.AssemblyId)">
<summary>
 Gets a unique assembly file name based on provided assembly id
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.AssemblyId.CanBeResolvedLocally(Nessos.Vagabond.AssemblyId,Nessos.Vagabond.AssemblyLoadPolicy)">
<summary>
 checks if provided assembly can be resolved from local environment
 based on the provided load policy
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.Assembly.get_AssemblyId(System.Reflection.Assembly)">
<summary>
 Gets the Assembly Id for assembly instance
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.AssemblySliceName.tryParseLocalDynamicAssemblySlice(System.Guid)">
<summary>
 try parsing a dynamic assembly slice that corresponds to particular Guid
</summary>
</member>
<member name="P:Nessos.Vagabond.AssemblyNaming.AssemblySliceName.tryParseDynamicAssemblySlice">
<summary>
 try parsing a dynamic assembly slice
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyNaming.AssemblySliceName.mkSliceName(System.Guid,System.String,System.Int32)">
<summary>
 Generates a slice name using given uuid, name and slice id.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyNaming.AssemblySliceName">

</member>
<member name="T:Nessos.Vagabond.AssemblyNaming">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.AssemblyParser.TypeParseInfo">
<summary>
 Parse info for dynamic type
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyParser.parseDynamicAssemblySlice(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,System.Reflection.Assembly)">
<summary>
 the main assembly parsing method
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyParser.tryRemapReferencedType(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,System.Type)">
<summary>
 used by the assembly parser to remap references to corresponding slices
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyParser.computeSliceData(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState)">
<summary>
 traverses a dynamic assembly and compiles and index of parse information
 to be used for the assembly parser configuration
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyParser">

</member>
<member name="M:Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyPublisher.PullAssemblies(Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.AssemblyId})">
<summary>
 request assembly packages from publisher.
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyPublisher.GetRequiredAssemblyInfo">
<summary>
 receives a collection of dependencies required by remote publisher.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyPublisher">
<summary>
 Defines an abstract assembly exporter; to be used by VagabondClient.
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyReceiver.PushAssemblies(Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.VagabondAssembly})">
<summary>
 upload a set of assembly packages to the remote party.
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyReceiver.GetLoadedAssemblyInfo(Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.AssemblyId})">
<summary>
 receives the assembly load state of the remote party for the given id&apos;s.
</summary>
</member>
<member name="T:Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyReceiver">
<summary>
 Defines an abstract assembly load target; to be used by VagabondServer.
</summary>
</member>
<member name="M:Nessos.Vagabond.AssemblyProtocols.VagabondManager.ReceiveDependencies(Nessos.Vagabond.VagabondManager,Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyPublisher,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyLoadPolicy})">
 <summary>
     Receive dependencies as supplied by the remote assembly publisher.
 </summary>
 <param name="publisher">The remote publisher</param>
 <param name="loadPolicy">Specifies local assembly resolution policy. Defaults to strong names only.</param>
</member>
<member name="M:Nessos.Vagabond.AssemblyProtocols.VagabondManager.SubmitObjectDependencies(Nessos.Vagabond.VagabondManager,Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyReceiver,System.Object,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
 <summary>
     Apply the built-in assembly distribution protocol using user-defined function.
 </summary>
 <param name="receiver">User provided assembly submit operation.</param>
 <param name="obj">Object, whose dependent assemblies are to be exported.</param>
 <param name="permitCompilation">Compile dynamic assemblies in the background, as required. Defaults to false.</param>
 <param name="includeNativeAssemblies">Include declared native assemblies if specified. Defaults to true.</param>
</member>
<member name="M:Nessos.Vagabond.AssemblyProtocols.VagabondManager.SubmitDependencies(Nessos.Vagabond.VagabondManager,Nessos.Vagabond.AssemblyProtocols.IRemoteAssemblyReceiver,System.Collections.Generic.IEnumerable{Nessos.Vagabond.AssemblyId})">
 <summary>
     Apply a built-in assembly distribution protocol using a user-defined submit function.
 </summary>
 <param name="receiver">User provided assembly submit operation.</param>
 <param name="assemblies">Assemblies to be exported.</param>
</member>
<member name="T:Nessos.Vagabond.AssemblyProtocols">
<summary>
 Vagabond assembly publish/receive protocol implementations
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Control.VagabondController">
<summary>
 A mailboxprocessor wrapper for handling vagabond state
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Control">

</member>
<member name="M:Nessos.Vagabond.DataDependencyManagement.importDataDependencies(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,Nessos.Vagabond.VagabondAssembly)">
<summary>
 import data dependencies to local AppDomain
</summary>
</member>
<member name="M:Nessos.Vagabond.DataDependencyManagement.importDataDependency(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,Nessos.Vagabond.VagabondAssembly,Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Nessos.Vagabond.DataDependencyInfo)">
<summary>
 import data dependency for locally loaded assembly slice
</summary>
</member>
<member name="M:Nessos.Vagabond.DataDependencyManagement.exportDataDependencies(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblySlice)">
<summary>
 export data dependencies given controller state for provided compiled dynamic assembly slice
</summary>
</member>
<member name="M:Nessos.Vagabond.DataDependencyManagement.exportDataDependency(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,System.String,System.Int32,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.AssemblyManagementTypes.DataExportState},System.Reflection.FieldInfo)">
<summary>
 export data dependency for locally generated slice
</summary>
</member>
<member name="M:Nessos.Vagabond.DataDependencyManagement.unpicklePersistedBinding(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,System.String)">
<summary>
 unpickle value from file
</summary>
</member>
<member name="M:Nessos.Vagabond.DataDependencyManagement.picklePersistedBinding(Nessos.Vagabond.AssemblyManagementTypes.VagabondState,System.String,System.Object)">
<summary>
 pickle value to file
</summary>
</member>
<member name="T:Nessos.Vagabond.DataDependencyManagement">

</member>
<member name="T:Nessos.Vagabond.DependencyAnalysis.Dependencies">
<summary>
 Assembly dependency and its directly referenced types
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.remapDependencies(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Reflection.Assembly,System.Collections.Generic.IEnumerable{System.Type}}})">
<summary>
 reassigns assemblies so that the correct assembly slices are matched
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.getDynamicDependenciesRequiringCompilation(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Reflection.Assembly,System.Collections.Generic.IEnumerable{System.Type}}})">
<summary>
 determines the assemblies that require slice compilation based on given dependency input
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.computeDependencies(System.Object)">
<summary>
 compute dependencies for supplied object graph
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.parseDynamicAssemblies(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
<summary>
 parse a collection of assemblies, identify the dynamic assemblies that require slice compilation
 the dynamic assemblies are then parsed to Cecil and sorted topologically for correct compilation order.
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.traverseDependencies(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState},System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
<summary>
 recursively traverse assembly dependency graph
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.tryResolveAssembly(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Microsoft.FSharp.Core.FSharpOption{Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState},System.String)">
<summary>
 locally resolve an assembly by qualified name
</summary>
</member>
<member name="P:Nessos.Vagabond.DependencyAnalysis.isIgnoredAssembly">
<summary>
 assemblies ignored by Vagabond during assembly traversal
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.gatherObjectDependencies(System.Object)">
<summary>
 returns all type depndencies for supplied object graph
</summary>
</member>
<member name="M:Nessos.Vagabond.DependencyAnalysis.getAssemblyOrdering(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.Reflection.Assembly,Microsoft.FSharp.Collections.FSharpList{System.Reflection.Assembly}}})">
<summary>
 Assembly-specific topological ordering for assembly dependencies
</summary>
</member>
<member name="T:Nessos.Vagabond.DependencyAnalysis">

</member>
<member name="P:Nessos.Vagabond.ExportableAssembly.ExportableAssembly.PersistedDataRaw">
<summary>
 Raw peristed data dependencies
</summary>
</member>
<member name="P:Nessos.Vagabond.ExportableAssembly.ExportableAssembly.Metadata">
<summary>
 Vagabond metadata * static initializers
</summary>
</member>
<member name="P:Nessos.Vagabond.ExportableAssembly.ExportableAssembly.SymbolsRaw">
<summary>
 Assembly symbols
</summary>
</member>
<member name="P:Nessos.Vagabond.ExportableAssembly.ExportableAssembly.ImageRaw">
<summary>
 Assembly binary image
</summary>
</member>
<member name="P:Nessos.Vagabond.ExportableAssembly.ExportableAssembly.Id">
<summary>
 Assembly Identifier
</summary>
</member>
<member name="T:Nessos.Vagabond.ExportableAssembly.ExportableAssembly">
<summary>
 A Vagabond assembly with all data loaded in-memory 
 for instant exportation.
</summary>
</member>
<member name="M:Nessos.Vagabond.ExportableAssembly.VagabondManager.CacheRawAssemblies(Nessos.Vagabond.VagabondManager,System.Collections.Generic.IEnumerable{Nessos.Vagabond.ExportableAssembly.ExportableAssembly})">
 <summary>
     Import raw assemblies to cache.
 </summary>
 <param name="ras">raw assembly inputs.</param>
</member>
<member name="M:Nessos.Vagabond.ExportableAssembly.VagabondManager.CacheRawAssembly(Nessos.Vagabond.VagabondManager,Nessos.Vagabond.ExportableAssembly.ExportableAssembly)">
 <summary>
     Import a raw assembly to cache.
 </summary>
 <param name="raw">raw assembly input.</param>
</member>
<member name="M:Nessos.Vagabond.ExportableAssembly.VagabondManager.CreateRawAssemblies(Nessos.Vagabond.VagabondManager,System.Collections.Generic.IEnumerable{Nessos.Vagabond.VagabondAssembly})">
 <summary>
     Copies raw vagabond assembly data to in-memory records.
 </summary>
 <param name="vas">Input vagabond assemblies.</param>
</member>
<member name="M:Nessos.Vagabond.ExportableAssembly.VagabondManager.CreateRawAssembly(Nessos.Vagabond.VagabondManager,Nessos.Vagabond.VagabondAssembly)">
 <summary>
     Copies raw vagabond assembly data to an in-memory record.
 </summary>
 <param name="va">Input vagabond assembly.</param>
</member>
<member name="T:Nessos.Vagabond.ExportableAssembly">
<summary>
 Raw in-memory assembly export/load implementations
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.Serialization.mkTypeNameConverter(Microsoft.FSharp.Core.FSharpOption{Nessos.FsPickler.ITypeNameConverter},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState})">
 <summary>
 Creates a typenameconverter passing a wrapped, user supplied type name converter instance
 </summary>
 <param name="wrappedConverter">User-supplied type converter.</param>
 <param name="stateF">Slice compiler state reader.</param>
</member>
<member name="T:Nessos.Vagabond.Serialization">

</member>
<member name="M:Nessos.Vagabond.SliceCompiler.compileDynamicAssemblySlices(Microsoft.FSharp.Core.FSharpFunc{System.Reflection.Assembly,System.Boolean},System.Boolean,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Microsoft.FSharp.Collections.FSharpList{System.Reflection.Assembly})">
<summary>
 compiles a collection of assemblies
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompiler.compileDynamicAssemblySlice(Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState,Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState,Microsoft.FSharp.Collections.FSharpMap{System.String,Nessos.Vagabond.AssemblyParser.TypeParseInfo},Mono.Cecil.AssemblyDefinition)">
<summary>
 compiles a slice of given dynamic assembly snapshot
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompiler.initCompilerState(System.Guid,Microsoft.FSharp.Collections.FSharpList{Nessos.Vagabond.IDynamicAssemblyProfile},System.String)">
<summary>
 create an initial, empty compiler state
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompiler.getAssemblyPath(System.String,System.String)">
<summary>
 creates a path for provided assembly name so that
 invalid characters are stripped and overwrites are avoided.
</summary>
</member>
<member name="T:Nessos.Vagabond.SliceCompiler">

</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.CreateAssemblySliceName">
<summary>
 Creates a slice assembly qualified name out of a dynamic assembly qualified name and slice id.
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.TryGetDynamicAssemblyId">
<summary>
 Parses a slice assembly qualified name, returning the dynamic assembly qualified name and slice id.
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.DynamicAssemblies">
<summary>
 List of currently compiled dynamic assemblies, indexed by qualified name
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.OutputDirectory">
<summary>
 Output directory used for slices
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.Profiles">
<summary>
 User-supplied dynamic assembly profiles
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.CompilerId">
<summary>
 Unique compiler identifier
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.TryFindSliceInfo(System.String)">
<summary>
 Returns contained dynamic assembly slice state using supplied slice qualified name
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState.IsLocalDynamicAssemblySlice(Nessos.Vagabond.AssemblyId)">
<summary>
 Returns true if local dynamic assembly slice id.
</summary>
</member>
<member name="T:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyCompilerState">
<summary>
 Global dynamic assembly compiler state
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.TypeIndex">
<summary>
 Dynamic type information indexed by name
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.GeneratedSlices">
<summary>
 Generated slices indexed by serial number
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.Profile">
<summary>
 User-supplied profile used for guiding slice compilation
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.DynamicAssembly">
<summary>
 Original dynamic assembly
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.Name">
<summary>
 System.Reflection.AssemblyName for dynamic assembly
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.LatestSlice">
<summary>
 Returns the latest generated slice for dynamic assembly
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.HasFreshTypes">
<summary>
 Returns true if dynamic assembly has new types that need to be compiled to slice
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.TryGetSlice(System.Type)">
<summary>
 Attempt to return slice that corresponds to supplied System.Type
</summary>
</member>
<member name="M:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState.Init(System.Reflection.Assembly,Nessos.Vagabond.IDynamicAssemblyProfile)">
<summary>
 Initialize a dynamic assembly state
</summary>
</member>
<member name="T:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblyState">
<summary>
 Dynamic assembly compilation state
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblySlice.StaticFields">
<summary>
 Static fields that are to be pickled by slice
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblySlice.Assembly">
<summary>
 System.Reflection.Assembly to slice
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblySlice.SliceId">
<summary>
 Slice serial number
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblySlice.DynamicAssemblyQualifiedName">
<summary>
 Qualified name of original dynamic assembly
</summary>
</member>
<member name="P:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblySlice.RequiresStaticInitialization">
<summary>
 Returns true if slice requires static initialization of fields
</summary>
</member>
<member name="T:Nessos.Vagabond.SliceCompilerTypes.DynamicAssemblySlice">
<summary>
 Contains information on compiled dynamic assembly slice
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.SliceCompilerTypes.DynamicTypeInfo">
<summary>
 Dynamic type metadata w.r.t. its containing static slice
</summary>
</member>
<member name="T:Nessos.Vagabond.SliceCompilerTypes">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.Utils.Async.RunSync``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>
     Runs the asynchronous computation and awaits its result.
     Preserves original stacktrace for any exception raised.
 </summary>
 <param name="workflow">Workflow to be run.</param>
 <param name="cancellationToken">Optioncal cancellation token.</param>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Nessos.Vagabond.Utils.Exn`1.Value">
<summary>
 evaluate, re-raising the exception if failed
</summary>
</member>
<member name="T:Nessos.Vagabond.Utils.Exn`1">
<summary>
 Value or exception
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.Utils.getSymbolsPath(System.String)">
<summary>
 gets symbols file path for given cached assembly
</summary>
</member>
<member name="P:Nessos.Vagabond.Utils.stripInvalidFileChars">
<summary>
 Strips invalid character from a candidate filename
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.Utils.tryGetTopologicalOrdering``1(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{``0}}})">
<summary>
 Attempt to compute a topological sorting for graph if DAG,
 If not DAG returns the reduced DAG for further debugging
</summary>
</member>
<member name="M:Nessos.Vagabond.Utils.registerAssemblyResolutionHandler">
<summary>
 registers an assembly resolution handler based on AppDomain lookups;
 this is needed since assembly lookups often fail when loaded at runtime.
</summary>
</member>
<member name="M:Nessos.Vagabond.Utils.tryLoadAssembly(System.String)">
<summary>
 try get assembly loaded in appdomain or load it now
</summary>
</member>
<member name="P:Nessos.Vagabond.Utils.tryGetLoadedAssembly">
<summary>
 try get assembly that is loaded in current appdomain
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Nessos.Vagabond.Utils.Map.addMany``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},System.Collections.Generic.IEnumerable{System.Tuple{``0,``1}})">
 <summary>
     add multiple key-value pairs to map.
 </summary>
 <param name="kvs">Input key-value pairs.</param>
 <param name="map">Input map.</param>
</member>
<member name="T:Nessos.Vagabond.Utils.Map">

</member>
<member name="M:Nessos.Vagabond.Utils.Convert.toBase32String(System.Byte[])">
<summary>
 convert bytes to base-32 string: useful for file names in case-insensitive file systems
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.Convert">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.Choice">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Nessos.Vagabond.Utils.Exn">

</member>
<member name="T:Nessos.Vagabond.Utils">

</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
</members>
</doc>
